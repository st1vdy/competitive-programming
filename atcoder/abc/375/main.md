# [Panasonic Programming Contest 2024（AtCoder Beginner Contest 375）](https://atcoder.jp/contests/abc375)

## **F - Road Blocked**

> 给定一个 $N$ 个点 $M$ 条边的无向图，$Q$ 次询问，每次询问有两种操作：
>
> 1. 断开第 $i$ 条边
> 2. 询问 $x,y$ 之间的最短路长度
>
> 保证第一种操作最多不超过 $300$ 次。$N\le300,Q\le 2e5$。

离线，然后倒序查询，这样就能把断边转换为加边。

每次加边（假设加的边是 $<u,v>$）之后，我们再更新全源最短路数组 $d[n][m]$，暴力枚举 $i,j$，尝试用
$$
d[i][u]+w(u,v)+d[v][j],\ d[i][v]+w(v,u)+d[u][j]
$$
去更新 $d[i][j]$ 即可。

## **G - Road Blocked 2**

> 给定一个 $N$ 个点 $M$ 条边的无向图，对于每一条边询问：
>
> - 断开第 $i$ 条边，从点1到点N的最短路长度是否变化。
>
> $N,M\le 2e5$。

和F的解题思路是基本一致的，我们先从点1、N分别跑两个单源最短路，记这两个单源最短路数组分别为 $d1[N],dn[N]$。

假设一条边 $<u,v>$ 可能成为点1到N最短路径上的一条边，那么就必须满足
$$
d1[N]=dn[1]=d1[u]+w(u,v)+dn[v]或者d1[v]+w(v,u)+dn[u]
$$
我们将所有满足该性质的边建图，然后图中所有的桥边就是会影响最短路长度的关键边了。

出了tarjan找桥的做法以外，我们还可以通过哈希的做法判断某条边是否为关键边，记录点1走到其余点的最短路方案数 $c1[N]$ 和点N走到其余点的最短路方案数 $cn[N]$，那么某一条边 $<u,v>$ 是关键边就必须满足（当然首先要满足 $d1[N]=dn[1]=d1[u]+w(u,v)+dn[v]或者d1[v]+w(v,u)+dn[u]$）
$$
c1[N]=cn[1]= c1[u]\times cn[v] 或者 c1[v]\times cn[u]
$$
需要注意的是，由于最短路的方案数可能很多，因此一般通过双哈希的方法来实现这个思路。