# AtCoder Beginner Contest 373

## **F - Knapsack with Diminishing Values**

> 有 $N$ 种物品，每种物品无数个，物品 $i$ 的价格为 $v_i$，重量为 $w_i$。
>
> 给定一个最大载重 $W$ 的背包，最大化装进背包物品的幸福值，幸福值的定义为：假设物品 $i$ 已经拿了 $k_i$ 件装入背包，则能获取的幸福值是 $k_iv_i-k_i^2$。
>
> $1\le N,W\le 3000$。

### **解法1**

如果直接用多重背包的思路做，有一个显然的 $O(NW^2)$ dp做法
$$
dp[i][j] = \max_{k} (dp[i-1][j-kw_i]+k\times(v_i-k))
$$
TLE的点在于：假设所有物品都是小重量物品（比如 $w_i=1$），那么最后一个维度的dp就会拉满。

一个解决的策略是：我们不要直接枚举物体，而是先按照重量将物品分组。这样我们就可以枚举物品的重量，然后同时处理所有的等重量物品。

注意到这里我们取了 $k_i$ 件物品能获得的价值是 $k_iv_i-k_i^2$。我们很自然地就能将这个条件转换为：取 $k_i$ 件物品 $i$ 等价于：

1. 取一件 $w=w_i,v=v_i-1$ 的物品
2. 取一件 $w=w_i,v=v_i-3$ 的物品
3. 取一件 $w=w_i,v=v_i-5$ 的物品
4. ……
5. 取一件 $w=w_i,v=v_i-2k_i+1$ 的物品

然后我们可以做一个特殊的01背包，将取 $k_i$ 件物品 $i$ 按上述方案转换，那么就有（$dp[i][j]$ 表示当前只用了单件重量 $\le w_i$ 的物品，装了 $j$ 重量时的最大幸福值）
$$
dp[w_i][j] = \max(dp[w_i-1][j-w_i]+value)
$$
这里的 $value$ 就表示了类似于上方等差数列式的物品（第一次拿是 $v_i-1$，第二次拿是 $v_i-3$，……）。这里可以贪心地思考，由于背包容量为 $W$，如果我们只拿单件重量为 $w_i$ 的物品，那么只需要拿价值最高的 $W/w_i$ 件即可，所以我们可以先将这 $W/w_i$ 件物品预处理好，然后再跑01背包即可。

复杂度为 $O(W^2\log W)$，这是因为按照价格分类后，01背包的物品数量就变成了 $W/1+W/2+\cdots$，这是调和级数。

### **解法2**

用 $g[x][y]$ 表示 $dp[i][x\times w_i+y]$，$g^\prime[x][y]=dp[i-1][x\times w_i+y]$，则
$$
\begin{aligned}
g[x][y] &= \max_{z\le x} (g^\prime[z][y]+(x-z)v_i-(x-z)^2)\\
&= \max_{z\le x} (g^\prime[z][y]-zv_i-z^2+2zx)-x^2+xv_i\\
\end{aligned}
$$
这是一个显然的斜率优化形式，$k=2z,m=g^\prime[z][y]-zv_i-z^2$。用单调栈维护即可达到 $O(NW)$ 或 $O(NW\log W)$ 的复杂度。

## **G - No Cross Matching**

https://codeforces.com/blog/entry/43463

简单的做法就是按照欧氏距离建费用流模型。证明只需要考虑：对于任意四个点而言，非退化四边形的对边长度之和一定短于对角线长度之和。