# 背包，子集和与(max,+)卷积

原文链接：https://codeforces.com/blog/entry/98663

## 前置芝士

让我们首先定义经典的背包问题、完全背包问题和子集和问题。

### 子集和问题

> 有 $N$ 件物品，第 $i$ 件物品的重量为 $w_i$。询问是否存在一个集合 $S$ 满足 $\sum\limits_{i \in S} w_i = W$。

### 0-1背包问题

> 有 $N$ 件物品，第 $i$ 件物品的重量为 $w_i$，价值为 $v_i$。找一个集合 $S$ 满足 $\sum\limits_{i \in S} w_i \leq W$ 并且最大化 $\sum\limits_{i \in S} v_i$。

### 完全背包问题

> 有 $N$ 种物品，第 $i$ 种物品的重量为 $w_i$，价值为 $v_i$；每种物品可以取无穷件。找一个可重复集合（multiset） $S$ 满足 $\sum\limits_{i \in S} w_i \leq W$ 并且最大化 $\sum\limits_{i \in S} v_i$。

### 传统方法

对于0-1背包和完全背包问题，传统方法的复杂度为 $O(NW)$；对于子集和问题，可以引入bitset优化达到 $O(\frac{NW}{w})$ 的复杂度。



## 本篇博客的内容

| 章节        | 结论                                                         |
| ----------- | ------------------------------------------------------------ |
| 子集和优化1 | 给定 $\sum w=W$，在 $O(\frac{W\sqrt{W}}{w})$ 的复杂度下求解 $\sum\limits_{i \in S} w_i = 1,2,3,\cdots,W$ 的所有子集和问题。 |
| 子集和优化2 | 给定 $w_i\le D$，对于任意的 $C$，在 $O(DC)$ 的复杂度下求解 $\sum\limits_{i \in S} w_i = C$ 的子集和问题。 |
| 背包优化1   |                                                              |
|             |                                                              |



## 子集和优化1

> 给定 $\sum w=W$，对于 $C=1,2,3,\cdots,W$，询问是否存在一个集合 $S$ 满足 $\sum\limits_{i \in S} w_i = C$。

这个问题可以在 $O(\frac{W\sqrt{W}}{w})$ 的复杂度下求解。

该问题可以类比多重背包问题的二进制分组优化，做到近似于 $O(\frac{W\sqrt{W} \log W}{w})$ 的复杂度。首先，我们先把所有等重量的物品聚合在一起，这样就得到了 $M(M\le N)$ 个元组 $(w_i,occ_i)$，其中 $w_i$ 表示物品重量，$occ_i$ 表示重量为 $w_i$ 的物品的总数。然后我们将 $occ_i$ 二进制分组，比如 $(w_i,15)$ 分解为 $\{w_i,2w_i,4w_i,8w_i\}$；$(w_i,12)$ 分解为 $\{w_i,2w_i,4w_i,5w_i\}$。

此外，众所周知，如果一个可重复集合中的元素之和为 $C$，那么这个可重集中的不重复元素数量至多为 $\sqrt{2C}$，也就是 $O(\sqrt{C})$ 量级。而在本问题中，由于 $occ_i\le W$，所以每一个元组在二进制分组后至多分解出 $\log W$ 个元素，加之 $w_i$ 已经去重，所以就有一个 $O(\frac{W\sqrt{W} \log W}{w})$ 的复杂度上界。

但是，实际上这个复杂度上界可以进一步逼近至 $O(\frac{W\sqrt{W}}{w})$。令 $S_{k}$ 表示所有元组 $(w_i,occ_i)$ 在二进制分组后得到的形如 $k\cdot w_i$ 的元素，我们只需要证明 $\sum\limits_{k\ge1} |S_{k}| = O( \sqrt W)$。容易注意到，对于任意元组 $(w_i,occ_i)$ 分解得到的元素，至多只有一个元素不是 $2^p\cdot w_i(p\in N)$ 的形式，因此如果我们证明了 $\sum\limits_{k=2^p} |S_{k}| = O( f(W) )$，那么就有 $\sum\limits_{k\ge1} |S_{k}| = O(f(W)+\sqrt W)$。

显然有 $\sum\limits_{i\in S_k}w_i\le\frac{W}{k}$，这可以进一步总结为 $|S_k|\le\sqrt{2W/k}$，因此
$$
\sum_{k=2^p}|S_k|\le \sum_{p\ge 0} \sqrt{\frac{2W}{2^p}} = \sqrt{2W} \cdot \sum_{p\ge 0}\frac{1}{\sqrt{2^p}} =O(\sqrt{W})
$$

### 例题

#### [CF755F. PolandBall and Gifts](https://codeforces.com/contest/755/problem/F)

> 给定大小为 $N$ 的排列 $P$ 和一个正整数 $K$。
>
> 有 $N$ 个人要送礼物，第 $i$ 个人会把他的礼物送给 $P_i$，但是有 $K$ 个人忘带了礼物。一个人当且仅当以下两个条件同时满足时才会受到礼物：
>
> 1. 他自己带了礼物
> 2. 要送他礼物的那个人带了礼物
>
> 询问：最少和最多有多少人收不到礼物？
>
> $N\le 1e6$。

由于是一个排列，因此可以归约到许多的环，每个环都可以认为是一个子问题：给定一个大小为 $N$ 的环，环上有 $K$ 个人忘带礼物，询问最少和最多有多少人收不到礼物？

这个问题的答案很简单：

1. 首先如果 $K=0$，那么所有人都能收到礼物
2. 如果 $K=1$，那么就会有 $2$ 个人收不到礼物（忘带礼物的人和他要送礼物的对象）
3. 如果 $K\gt 1$，那么就要分类讨论了：最优情况下，显然是连续的 $K$ 个人不带礼物时收不到礼物的人数最少，此时收得到礼物的人数为 $\max(0,N-K-1)$。最劣情况下，显然应该是每隔一个人收不到礼物（即第 $1,3,5,\cdots$ 个人收不到礼物），此时收得到礼物的人数为 $\max(0,N-2K)$。

然后再分析本题的问题：最少和最多有多少人收不到礼物？其中最多有多少个人收不到礼物是很简单的，因为对于一个环的子问题而言，收得到礼物的人数为 $\max(0,N-2K)$，也就是每多一个没带礼物的人，就会减少 $2$ 个收得到礼物的人（除了环为奇数的情况，最后会剩下一个人），因此我们只要贪心就好了。

再看最少有多少人收不到礼物的情况，最优情况肯定是恰好 $N-K$ 个人都收到了礼物，此时对应的情况是：存在数个环，这些环的大小之和恰好为 $N-K$；如果不存在这样的环，那么就会多一个人收不到礼物（再加入一个不完整的环）。



## 子集和优化2

> 有 $N$ 件物品，第 $i$ 件物品的重量 $w_i\le D$，询问是否存在一个集合 $S$ 满足 $\sum\limits_{i\in S}w_i=W$？

这个问题可以在 $O(ND)$ 的复杂度下解决。首先，如果 $\sum w_i\lt W$，答案显然是否，因此接下来不再考虑这种情况。

让我们先找到最大的 $k$ 使得 $\sum_{i=1}^k w_i\lt W$。然后，这个优化的大致思路就是：我们初始得到了一个集合 $S$ 且 $S$ 中的元素之和为 $w_1+w_2+\cdots+w_k$，然后我们要么对于 $i\le k$ 减去 $w_i$，要么对于 $i\gt k$ 加上 $w_i$，如果我们按照某种顺序执行两种操作，就会使得元素之和的值域维持在 $[W-D,W+D]$。具体地，如果当前权重超过 $W$，就减去一些值；否则就加上一些值。

定义 $can(total,l,r)$ 表示一个dp状态：返回是否存在 $\lambda_l,\lambda_{l+1},\cdots,\lambda_{r}\in [0,1]$ 使得 $\sum\limits_{i=1}^{l-1}w_i + \sum\limits_{i=l}^{r} \lambda_i w_i = total$，这里 $total\in[W-D,W+D]$。

注意到，如果 $can(total,l,r)=\text{true}$，那么 $can(total,l-1,r)$ 也为真，因此这个dp状态关于参数 $l$ 是单调的。因此，我们进一步定义出一个新的dp状态 $dp(total,r)$ 表示满足 $can(total,l,r)=\text{true}$ 的 $l$ 的最大值。

此外，$can(total,l,r)$ 在维度 $r$ 上也是单调的，因此有 $dp(total,r)\le dp(total,r+1)$。

然后考虑转移：

从 $dp(total,r)=l$，我们可以拓展 $r$，转移至 $dp(total+w_{r+1},r+1)$ 或者 $dp(total,r+1)$。我们也可以拓展 $l$ 转移至 $dp(total-w_{l^\prime},r)=l^\prime$，这里 $l^\prime\lt l$。但是，这个转移对于每个状态而言是 $O(N)$ 的复杂度，总体复杂度就不是 $O(ND)$ 的。

但是，实际上我们并不需要遍历所有的 $l^\prime\lt l$ 进行转移，一个更合理的区间是 $dp(total,r-1) \leq l' < dp(total,r)=l$，因为 $dp(total,r-1)$ 会拓展 $r$ 到状态 $dp(total,r)$。我们进行摊还分析可知 $l^\prime$ 的转移数是 $O(ND)$ 的。

### 转化为随机游走

除了这种做法，还有一种~~不确定正确性的~~做法，复杂度~~大约是~~ $O(\frac{ND\sqrt{N}}{32})$。

首先还是先找到最大的 $k$ 满足 $\sum_{i=1}^k w_i\lt W$，我们可以将这个子集和问题转化为：在集合 $\{-w_1,-w_2,\ldots,-w_k,w_{k+1},\ldots,w_N\}$ 中是否存在一个子集和为 $C-\sum_{i=1}^k w_i$。

如果我们事先shuffle所有 $w_i$，那么这个问题~~可以近似地看作~~一个随机游走问题，你初始在原点，每次随机挑选集合中的元素走一步，问能否抵达点 $C-\sum_{i=1}^k w_i$。由于 $C-\sum_{i=1}^k w_i\lt D$，而 $D$ 在这类优化中是一个很小的数字，因此我们在复杂度分析的场景下可以认为 $D\to 0$，也就是随机游走走回原点。根据重对数率，对于标准的一维对称随机游走，每一步 $X_i$ 独立同分布且 $E(X_i)=0,Var(X_i)=\sigma^2$，随机游走的最大偏移量几乎必然在 $O(2N\log\log N)$ 的量级上下波动。在本例中可以推出随机游走的最大偏移量是 $O(D\sqrt{2N\log\log N})$ 的量级，由于 $\log\log N$ 很小，我们~~直接忽略这一项~~，也就是说最大偏移量的量级是 $O(D\sqrt{N})$。用bitset维护这个流程，即可得到一个 $O(\frac{ND\sqrt{N}}{32})$ 的做法。

### 例题

#### [**ABC221G - Jumping sequence**]()

> 有一个无限大的平面直角坐标系，初始时你在 $(0,0)$ 处。给你一个长度为 $N$ 的序列 $D$，你可以移动 $N$ 步，每一步可以选择：
>
> - 向上移动 $D_i$ 距离
> - 向下移动 $D_i$ 距离
> - 向左移动 $D_i$ 距离
> - 向右移动 $D_i$ 距离
>
> 询问：在移动 $N$ 步后是否可以落在点 $(A,B)$ 处？如果存在，给出一种构造。
>
> $N\le 2e3; |A|,|B|\le3.6e6;D_i\le1.8e3$。

显然这是经典的二维随机游走问题的变形，可以先用经典的坐标轴旋转 $45^\circ$ 的方法进行处理，将坐标 $(X,Y)$ 映射到 $(X+Y,X-Y)$，那么每一次随机移动就可以视作 $(\pm D_i,\pm D_i)$ 四选一，这样我们就把一个二维随机游走问题转化为了两个一维问题：在 $X$ 轴上能否走到 $A+B$，在 $Y$ 轴上能否走到 $A-B$。

不考虑构造方案的话，直接用bitset就能做到 $O(\frac{N(|A|+|B|)}{w})$ 的复杂度了。如果考虑构造方案，那我们还需要存储每一步的bitset，在本题中就是 $2e3$ 个大小为 $2e3\times 1.8e3\times 2$ 的bitset（乘2的原因是我们需要处理正负两种情况），发现需要 $1.7G$ 内存，但是题目只给了 $1G$！

考虑进一步优化空间，也就是优化这么一个问题：是否存在 $s_i=\pm1$ 使得 $\sum_{i=1}^N s_iD_i = A+B$（$A-B$ 同理）。记 $S=\sum_{i=1}^N D_i$，等式两边都加上 $S$，则问题变成了：是否存在 $t_i=0,1$ 使得 $\sum_{i=1}^N t_i D_i = \frac{A+B+S}{2}$，也就转化为了子集和问题。并且我们需要枚举的值域折半（只需要枚举正半部分），恰好符合题目给出的内存范围。

